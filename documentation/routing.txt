HIGHLIGHTS de este brainstorm:

Las peticiones se pueden enrutar hacia CUALQUIER INVOCABLE DE UNA CLASE
e.g. 
//GET people ->   PersonContollerMyClass->collection()
Route::request('GET', 'people', 'PersonContollerMyClass', 'collection')

Lo que retorne esa ejecucion, SEA LO QUE SEA, es el modelo
e.g.  return Person_Entity::collection();

Los modelos se pueden enrutar (segun su tipo) hacia PLANTILLAS
e.g. //collection ->  types/collections
Route::model('Phidias\ORM\Collection', 'types/collection')

Para una plantilla se puede obtener una vista dependiendo del formato e idioma deseados
e.g. Route::getView('types/collection');
retorna array(
    'component'	=> 'Phidias\Component\View',
    'template' => 'views/json/types/collection/json',
    'type'     => 'application/json',
    'url'      => '...'
);


------------------------------->


La idea del enrutador es traducir un request (metodo y recurso)
a una funcion php a ejecutar (clase, metodo y argumentos)

Habia determinado inicialmente que como regla general los recursos se traducian directamente en clases
y sobre ellas se ejecutaba un metodo llamado igual que el metodo del request

por ejemplo, el request GET people se traduciria en "People_Resource->get()"

Creo que se puede extender la nocion de este router para introducir mucha flexibilidad en el sistema.

Reglas de routing:
Route::map($requestMethod, $pattern, $class, $method, $arguments)

Reglas basicas:

//GET people --> Person_Controller->collection()
Route::map('get', 'people', 'Person_Controller', 'collection');

//Todas las palabras precedidas de ":" se asumen como argumentos
//GET people/:personID --> Person_Controller->single(:personID)
Route::map('get', 'people/:personID', 'Person_Controller', 'single');

//GET people/:personID/quirks --> Person_Controller->quirks(:personID)
Route::map('get', 'people/:personID/quirks', 'Person_Controller', 'quirks');


Reglas complejas:
El router puede recibir una funcion que retorna un invocable (array('class', 'method', 'arguments'))

Route::map('*', '*', function($method, $uri) {
	
	//Determine classname from resource
	//e.g.  foo/bar/:arg/shoo -> Foo_Bar_Shoo_Controller

	$rawParts = explode('/', $resource);
	$parts = array();
	foreach ($rawParts as $part) {
		if (substr($part, 0, 1) !== ':') {
			$parts[] = $part;
		}
	}

	$class = implode('_', array_map('ucfirst', $parts)).'_Controller';

	return array(
		'class'		=> $class,
		'method'	=> $method,
		'arguments'	=> array()
	);

})

... en fin, el comportamiento de "matchUsingName" puede modelarse como una regla de enrutamiento.

Comportamiento como el de Laravel (GET foo/bar/shoo ->  Foo_Bar->getShoo()) tambien puede modelarse de esta forma como una regla de enrutamiento.

Al final el controlador de recurso harÃ¡ lo siguiente:

1. Obtener un invocable a partir de la ruta. (Lanzar notFoundException cuando la ruta no se encuentre)
2. Los invocables NO se garantiza que esten implementados.  Verificar implementacion (is_callable) y lanzar methodNotImplemented en caso de no ser invocable
3. Crear una instancia de $invocable['class'] enviando el arreglo de atributos en el constructor
4. Invocar $invocable['class']->$invocable['method']($invocable['arguments'])


La idea es que el usuario pueda definir CUALQUIER invocable.  Pero... el model ?
Pues bien, el controlador retorna un modelo.  Sea lo que sea que el controlador retorna se asume que es el modelo.

class PeopleResource
{
	public function __construct($attributes)
	{
		//whatever you want
	}

	public function get()
	{
		return $collection;
	}

	public function aha()
	{
		$model = new Model;
		$model->set('foo', 'bar');
		$model->set('shoo', 'bhar');

		return $model;
	}

	public function nothing()
	{

	}
}


Si el controlador no retorna nada, asumimos que el modelo es el mismo objeto controlador.


Entonces, para lograr el comportamiento "v3", primero declaramos una regla de enrutamiento que 
transforme el recurso en una clase *_Controller que extienda la clase base Controller:

Base Controller:
<?php
class Controller
{
	private $model;
	private $attributes;
	private $view;

	public function __construct($attr)
	{
		$this->attributes = $attr;
	}

	protected function set($variable, $value)
	{
		$this->model[$variable] = $value;
	}

	protected function useView($view)
	{
		$this->view = $view;
	}

	public function getView()
	{
		return $this->view;
	}
}


y luego, un INTERPRETE DE DATOS.   El interprete de datos es el encargado de, dado un "dato" (cualquier cosa que retorne un controller, o el mismo objeto controller)
encontrar una PLANTILLA correspondiente. La PLANTILLA es una cadena, que simplemente identifica una plantilla de forma unica, similar a un URI.
e.g. person/collection

Asi, por ejemplo:

Model::interpreter('array', 'types/array');

La vista "types/array" es enrutada y segun los tipos de datos aceptados terminara


Model::interpreter('Controller', function($model) {

	$view = $model->getView();
	......
	return 'foo/bar/shoo';
})

Finalmente, el enrutador puede tomar un UVI y darnos la plantilla mas adecuada segun los mimeTypes aceptados (y, adicionalmente, una clase View que la renderice.

Ej:  foo/bar/shoo  puede enrutarse a  views/html/foo/bar/shoo.phtml o views/json/foo/bar/shoo.json

Model::interpreter(TIPO, UVI)

TIPO es el resultado de ejecutar gettype sobre el modelo dado,  o, si gettype es "object", el resultado de get_class


Mejor:

Route::request($method, $pattern, $class, $method, $arguments);

//o tambien
Route::request($method, $pattern, $builder);
//donde $builder es una funcion que retorna un arreglo con informacion del callback:  class, method y arguments

Luego
Route::model($type, $template);

//o tambien
Route::model($type, $builder);
//donde $builder es una funcion que retorna una cadena con la plantilla


//finalmente
Route::getController($request, $method); //retorna el callback: class, method y arguments
Route::getView($template); //retorna la vista: component, template, type, publicURL