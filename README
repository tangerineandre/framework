Phidias Framework v2.0

Phidias Framework es un framework PHP de alto nivel para el desarrollo de aplicaciones web RESTful
(http://en.wikipedia.org/wiki/Representational_state_transfer)

Una aplicación web restful recibe peticiones HTTP [request],
ejecuta una lógica asociada [controller] la cual genera un conjunto de datos [model]
que es luego asociado a una vista [view] que organiza el contenido para ser retornado [response].



REQUESTS:

e.g. Al digitar la siguiente URL en un navegador:
http://myapp.com/blog/articles/politics/some-title?size=20&safe=1

se ejecuta la siguiente petición HTTP:

GET /blog/articles/politics/some-title?size=20&safe=1 HTTP/1.0

En la cual se identifican los siguientes componentes

GET                                 ----> método [method]
blog/articles/politics/some-title   ----> recurso [resource]
size=20&safe=1                      ----> atributos [attributes]

La aplicación web establece un "mapeo de recursos" [resource mapping] mediante
el cual determina un controlador [controller] encargado de ejecutar la lógica asociada al recurso [resource] solicitado

El controlador [controller] es una función invocable compuesta por:

Clase [controller class]
Método [controller method] y
Argumentos [controller arguments]


MAPEO DE RECURSOS [resource mapping]

Dentro de phidias framework se configuran "reglas de mapeo" [mapping rules] de la siguiente manera:

'[resource pattern]' => array('[controller class]', '[controller method]')

Cuando el recurso solicitado [resource] corresponde con el patron de recurso [resource pattern] de una regla [mapping rule]
el sistema ejecuta la función invocable "controller method" de la clase "controller class".


EJEMPLO:

Se define en la aplicación la siguiente regla de mapeo:
'articles' => array('Article_Controller', 'main')

Cuando se recibe una petición HTTP a http://myapp.com/articles/
se identifica que "articles" es el recurso a ejecutar.

Al parear el recurso con la regla de mapeo el sistema ejecuta

Article_Controller::main()


Adicionalmente, en un patron de recurso se pueden definir wildcards o variables, que son
enviadas como argumentos al controlador [controller] identificado, asi:


EJEMPLO:

Dada la siguiente regla de mapeo
'articles/:title' => array('Article_Controller', 'details')

Al recibir una peticion al recurso "articles/some-title" el sistema ejecuta

Article_Controller::details('some-title')





Permisos:

La generalidad es que los permisos se basan en permitir o denegar acceso a los recursos segun un rol.
Por ejemplo: "Los autores pueden crear articulos, los editores pueden modifiarlos y los visitantes pueden consultarlos".

He visto muchas implementaciones de control de acceso basado en roles (RBAC) pero la experiencia me ha
enseñado que se deben modelar reglas de acceso mucho mas complejas que simplemente permitir o denegar segun el rol.

Cosas como "el usuario puede consultar las notas de sus hijos",  "el alumno solo puede consultar el contenido de cursos a los que esta inscrito",
"los usuarios morosos no pueden consultar el boletin" y, en general, condicionar el acceso no segun el rol (propiamente) sino segun la LOGICA detras
del recursos que se está consultando.


En Phidias todo recurso se traduce en un controlador (clase y metodo), sus argumentos y sus atributos.

Por ejemplo,

people/7/messages/inbox?limit=10  se mapea como:
controlador:  Messages::folder
argumentos:   7, inbox
atributos:    limit=10

people/7/messages/trash?limit=10  se mapea como:
controlador:  Messages::folder
argumentos:   7, trash
atributos:    limit=10


Supongamos que yo quiero establecer los siguientes permisos:

Cualquier persona puede consultar su propio inbox, y el de sus hijos
Los usuarios con rol "auditor" pueden consultar la papelera de personas que estan en sus grupos
(El caso hipotetico es que quieren que los usuarios crean que estan borrando mensajes, mientras estan siendo husmeados por un auditor)

A partir de la informacion que nos otorga Phidias, esto podria modelarse como:

controlador: Message::folder

accesible si:
primer argumento = YO y folder = 'inbox'
o
primer argumento = HIJO MIO y folder = 'inbox'
o
primer argumento IN (persona en grupo donde yo = AUDITOR) y folder = 'trash'

basicamente, un motor de CONDICIONES.

pareciera que solo es necesario condicionar segun argumentos (los atributos, diria yo, son parametros modificables libremente una vez se ha otorgado acceso, no ?)

entonces necesito una lista predefinida de funciones ("condiciones") que reciban un argumento.  Por ejemplo:

Authentication_Condition::isMe($foo);
Person_Relation_Condition::areRelated($person1, $person2, $relation = 'ANY');
String_Condition::equals($foo, $bar);

Las reglas anteriores se podrian modelar:

(Authentication_Condition::isMe($arguments[0]) && String_Condition::equals($arguments[1], 'inbox)) ||
(Person_Relation_Condition::areRelated(Authentication::$me, $arguments[0]) && String_Condition::equals($arguments[1], 'inbox)) ||
(Group_Condition::hasPerson(Authentication::myGroups('auditor'), $arguments[0]) && String_Condition::equals($arguments[1], 'trash'))

pues hasta ahora las condiciones son sobre argumentos, O sobre propiedades se la autenticacion ("yo", "mis grupos").. mmmm...

... que tal algo como:

1. Escoja una condicion:
Authentication_Condition::isMe
String_Condition::equals
Person_Relation_Condition::areRelated
Group_Condition::hasPerson

2. ahora para cada posible argumento de la condicion, escoja un VALOR:
$arguments[0]
$arguments[1]
....
Authentication::$me
Authentication::myGroups('algun rol')
Cadena arbitraria

3. Si aplica, configure el VALOR (como establecer el 'algun rol', la cadena arbitraria, o lo que sea),

.... otra opcion:


Crear una CONDICION:

1. Escoja [y configure] el ARGUMENTO:
$arguments[0]
$arguments[1]
....
Authentication::$me
Authentication::myGroups('algun rol')
Cadena arbitraria

2. Escoja la FUNCION:
Authentication_Condition::isMe
String_Condition::equals
Person_Relation_Condition::areRelated
Group_Condition::hasPerson
Person_Condition::hasGender($person, $gender);


No se, veamos un ejemplo muy basico:  Permitir el acceso cuando el primer argumento es "hola":

$arguments[0]
String_Condition::equals --> 'hola'

Mas basico todavia... que tal si quiero poner una regla que NO depende de los argumentos?
Algo como "permitir el acceso si la persona que consulta tiene ID 7" (o genero femenino):

1. Authentication::$me
2. Person_Condition::hasGender
  2.1. "femenino"

Ok, segun este flujo de trabajo, lo que se escoge de primero es el PRIMER ARGUMENTO de la funcion
los ARGUMENTOS pueden tener configuracion arbitraria.
Si la funcion recibe mas de un argumento, entonces el paso seguido es escogerlos [y configurarlos]


Tratemos de formalizar un poco esto:

El acceso a un CONTROLADOR se otorga cuando se cumple al menos una REGLA (regla1 || regla2 || regla3 ... )
Una REGLA es un conjunto de CONDICIONES (condicion1 [&& condicion2] [&& condicion3]...)
Una CONDICION determina una FUNCION y sus ARGUMENTOS
Un ARGUMENTO es un valor, que opcionalmente tiene alguna configuracion arbitraria


... la otra cosa es que tambien quiero poder modificar LOGICA segun ciertas reglas,
por ejemplo, dado un recurso que lista materias, yo quiero listar unicamente aquellas en las cuales yo soy profesor.
... sssso? como hacer?  bueno, eso ya es mas bien un tema de la logica interna del controlador.
Un ejemplo de esto es el buscador de audiencias.  Este tiene una opcion de restringir la audiencia... pero eso hace
parte de la misma logica interna (Audience::find() internamente hace una consulta de restricciones configuradas, y el respectivo intersect)

